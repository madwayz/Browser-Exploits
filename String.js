String.from­Word = function (w­Value) {
  // Return a BSTR that contains the desired DWORD in its string data.
  return String.from­Char­Code(w­Value);
}
String.from­Words = function (aw­Values) {
  // Return a BSTR that contains the desired DWORD in its string data.
  return String.from­Char­Code.apply(0, aw­Values);
}
String.from­DWord = function (dw­Value) {
  // Return a BSTR that contains the desired DWORD in its string data.
  return String.from­Char­Code(dw­Value & 0x­FFFF, dw­Value >>> 16);
}
String.from­DWords = function (au­Values) {
  var as­DWords = new Array(au­Values.length);
  for (var i = 0; i < au­Values.length; i++) {
    as­DWords[i] = String.from­DWord(au­Values[i]);
  }
  return as­DWords.join("");
}

String.prototype.repeat = function (u­Count) {
  // Return the requested number of concatenated copies of the string.
  var s­Repeated­String = "",
      u­Left­Most­Bit = 1 << (Math.ceil(Math.log(u­Count + 1) / Math.log(2)) - 1);
  for (var u­Bit = u­Left­Most­Bit; u­Bit > 0; u­Bit = u­Bit >>> 1) {
    s­Repeated­String += s­Repeated­String;
    if (u­Count & u­Bit) s­Repeated­String += this;
  }
  return s­Repeated­String;
}
String.create­Buffer = function(u­Size, u­Index­Size) {
  // Create a BSTR of the right size to be used as a buffer of the requested size, taking into account the 4 byte
  // "length" header and 2 byte "\0" footer. The optional argument u­Index­Size can be 1, 2, 4 or 8, at which point the 
  // buffer will be filled with indices of said size (this is slower but useful for debugging).
  if (!u­Index­Size) return "\u­DEAD".repeat(u­Size / 2 - 3);
  var au­Buffer­Char­Codes = new Array((u­Size - 4) / 2 - 1);
  var u­MSB = u­Index­Size == 8 ? 8 : 4; // Most significant byte.
  for (var u­Char­Index = 0, u­Byte­Index = 4; u­Char­Index < au­Buffer­Char­Codes.length; u­Char­Index++, u­Byte­Index +=2) {
    if (u­Index­Size == 1) {
      au­Buffer­Char­Codes[u­Char­Index] = u­Byte­Index + ((u­Byte­Index + 1) << 8);
    } else {
      // Set high bits to prevents both NULLs and valid pointers to userland addresses.
      au­Buffer­Char­Codes[u­Char­Index] = 0x­F000 + (u­Byte­Index % u­Index­Size == 0 ? u­Byte­Index & 0x­FFF : 0);
    }
  }
  return String.from­Char­Code.apply([][0], au­Buffer­Char­Codes);
}
String.prototype.clone = function () {
  // Create a copy of a BSTR in memory.
  s­String = this.substr(0, this.length);
  s­String.length;
  return s­String;
}

String.prototype.replace­DWord = function (u­Byte­Offset, dw­Value) {
  // Return a copy of a string with the given dword value stored at the given offset.
  // u­Offset can be a value beyond the end of the string, in which case it will "wrap".
  return this.replace­Word(u­Byte­Offset, dw­Value & 0x­FFFF).replace­Word(u­Byte­Offset + 2, dw­Value >> 16);
}

String.prototype.replace­Word = function (u­Byte­Offset, w­Value) {
  // Return a copy of a string with the given word value stored at the given offset.
  // u­Offset can be a value beyond the end of the string, in which case it will "wrap".
  if (u­Byte­Offset & 1) {
    return this.replace­Byte(u­Byte­Offset, w­Value & 0x­FF).replace­Byte(u­Byte­Offset + 1, w­Value >> 8);
  } else {
    var u­Char­Index = (u­Byte­Offset >>> 1) % this.length;
    return this.substr(0, u­Char­Index) + String.from­Word(w­Value) + this.substr(u­Char­Index + 1);
  }
}
String.prototype.replace­Byte = function (u­Byte­Offset, b­Value) {
  // Return a copy of a string with the given byte value stored at the given offset.
  // u­Offset can be a value beyond the end of the string, in which case it will "wrap".
  var u­Char­Index = (u­Byte­Offset >>> 1) % this.length,
      w­Value = this.char­Code­At(u­Char­Index);
  if (u­Byte­Offset & 1) {
    w­Value = (w­Value & 0x­FF) + ((b­Value & 0x­FF) << 8);
  } else {
    w­Value = (w­Value & 0x­FF00) + (b­Value & 0x­FF);
  }
  return this.substr(0, u­Char­Index) + String.from­Word(w­Value) + this.substr(u­Char­Index + 1);
}

String.prototype.replace­Buffer­DWord = function (u­Byte­Offset, u­Value) {
  // Return a copy of a BSTR with the given dword value store at the given offset.
  if (u­Byte­Offset & 1) throw new Error("u­Byte­Offset (" + u­Byte­Offset.to­String(16) + ") must be Word aligned");
  if (u­Byte­Offset < 4) throw new Error("u­Byte­Offset (" + u­Byte­Offset.to­String(16) + ") overlaps BSTR size dword.");
  var u­Char­Index = u­Byte­Offset / 2 - 2;
  if (u­Char­Index == this.length - 1) throw new Error("u­Byte­Offset (" + u­Byte­Offset.to­String(16) + ") overlaps BSTR terminating NULL.");
  return this.substr(0, u­Char­Index) + String.from­DWord(u­Value) + this.substr(u­Char­Index + 2);
}